{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\ud83c\udfb6 \u0908-\u092f\u0902\u0924\u094d\u0930\u093e \u092e\u093f\u0921\u0940 \u0935\u093e\u0926\u0928 \ud83c\udfb9 \ud83c\udfb9 e-Yantra MIDI Vaadan \ud83c\udfb6 Introduction Understanding MIDI MIDI stands for M usical I nstrument D igital I nterface. Wikipedia says, MIDI is a technical standard that describes a communications protocol, digital interface, and electrical connectors that connect a wide variety of electronic musical instruments, computers, and related audio devices for playing, editing and recording music. In simple terms, MIDI is standard medium for synchronization of different musical instruments manufactured by different companies with a common music production software (commonly known as DAW(Digital Audio Workstation) ). MIDI messages can be exchanged via a MIDI port/ USB port with any audio software for producing,editing and recording music. One can get a deeper insight about MIDI by referring midi.org . e-Yantra MIDI Vaadan e-Yantra MIDI Vaadan is a real time MIDI controller. It transmits appropriate MIDI data to MIDI-enabled devices/software, typically to trigger sounds and control parameters of an electronic music. The parameters include pitch, volume, bank selection, modulation etc. It has a number of inputs which send respective MIDI messages to a DAW (Digital Audio Workstation) to generate and control musical parameters. The inputs can also be custom mapped to control different parameters in the DAW.","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#understanding-midi","text":"MIDI stands for M usical I nstrument D igital I nterface. Wikipedia says, MIDI is a technical standard that describes a communications protocol, digital interface, and electrical connectors that connect a wide variety of electronic musical instruments, computers, and related audio devices for playing, editing and recording music. In simple terms, MIDI is standard medium for synchronization of different musical instruments manufactured by different companies with a common music production software (commonly known as DAW(Digital Audio Workstation) ). MIDI messages can be exchanged via a MIDI port/ USB port with any audio software for producing,editing and recording music. One can get a deeper insight about MIDI by referring midi.org .","title":"Understanding MIDI"},{"location":"#e-yantra-midi-vaadan","text":"e-Yantra MIDI Vaadan is a real time MIDI controller. It transmits appropriate MIDI data to MIDI-enabled devices/software, typically to trigger sounds and control parameters of an electronic music. The parameters include pitch, volume, bank selection, modulation etc. It has a number of inputs which send respective MIDI messages to a DAW (Digital Audio Workstation) to generate and control musical parameters. The inputs can also be custom mapped to control different parameters in the DAW.","title":"e-Yantra MIDI Vaadan"},{"location":"Firmware/","text":"Code Go through the following code. Pin declarations and definitions #include <Arduino_FreeRTOS.h> #include \"queue.h\" #include <Keypad.h> //analog input pins #define pitchpin A0 #define modulationpin A2 #define volumepin A1 //Keypad related declarations const byte ROWS = 4; //four rows const byte COLS = 4; //four columns char keys1[ROWS][COLS] = { {'A', 'B', 'C', 'D'}, {'E', 'F', 'G', 'H'}, {'I', 'J', 'K', 'L'}, {'M', 'N', 'O', 'P'} }; byte rowPins[ROWS] = {22, 24, 26, 28}; //connect to the row pinouts of the kpd1 byte colPins[COLS] = {29, 27, 25, 23}; //connect to the column pinouts of the kpd1 Keypad kpd1 = Keypad( makeKeymap(keys1), rowPins, colPins, ROWS, COLS ); char keys2[ROWS][COLS] = { {'A', 'B', 'C', 'D'}, {'E', 'F', 'G', 'H'}, {'I', 'J', 'K', 'L'}, {'M', 'N', 'O', 'P'} }; byte colpins[COLS] = {47, 42, 36, 34}; //connect to the row pinouts of the kpd2 byte rowpins[ROWS] = {48, 43, 37, 35}; //connect to the column pinouts of the kpd2 Keypad kpd2 = Keypad( makeKeymap(keys2), rowpins, colpins, ROWS, COLS ); int volume = 100; //Interrupt related declarations #define enc1A 20 #define enc2A 21 #define enc1B 31 #define enc2B 33 #define pb1 18 //pushbutton #define pb2 19 //pushbutton volatile int count1 = 64; volatile int count2 = 64; volatile int count = 0; volatile long last1 = 0; volatile long last2 = 0; //Queue Creation QueueHandle_t Queue1,Queue2; int prev1 = 0, prev2 = 515, prev3 = 517; int vol = 100; void setup() { Serial.begin(115200); pinMode(pitchpin, INPUT); pinMode(modulationpin, INPUT); pinMode(volumepin, INPUT); interrupt_set(); xTaskCreate(Readkey1, \"one\", 128, NULL, 0, NULL); //task for pushbutton keypad xTaskCreate(Readkey2, \"two\", 128, NULL, 0, NULL); //task for membrane keypad xTaskCreate(getPitchMod, \"pitch_mod\", 128, NULL, 2, NULL); //task for pitch bends xTaskCreate(getVolume, \"vol\", 100, NULL, 2, NULL); //task for channel volume Queue1 = xQueueCreate(5, sizeof(int32_t)); Queue2 = xQueueCreate(5, sizeof(int32_t)); } void loop() { } void Midi(int status, int dat1, int dat2) { //MIDI message structure consists of three bytes Serial.write(status); Serial.write(dat1); Serial.write(dat2); } Interrupts void interrupt_set() { pinMode( enc1A, INPUT); digitalWrite(enc1A, HIGH); //Assign an initial state to prevent floating pinMode(enc1B, INPUT); digitalWrite(enc1B, HIGH); //Assign an initial state to prevent floating attachInterrupt(digitalPinToInterrupt(enc1A), Count1, RISING); //interrupt on Rising edge pinMode( enc2A, INPUT); digitalWrite(enc2A, HIGH); //Assign an initial state to prevent floating pinMode(enc2B, INPUT); digitalWrite(enc2B, HIGH); //Assign an initial state to prevent floating attachInterrupt(digitalPinToInterrupt(enc2A), Count2, RISING); //interrupt on Rising edge pinMode( pb1, INPUT); digitalWrite(pb1, HIGH); //Assign an initial state to prevent floating attachInterrupt(digitalPinToInterrupt(pb1), PB1, RISING); //interrupt on Rising edge pinMode( pb2, INPUT); digitalWrite(pb2, HIGH); //Assign an initial state to prevent floating attachInterrupt(digitalPinToInterrupt(pb2), PB2, RISING); //interrupt on Rising edge pinMode(18, INPUT); pinMode(19, INPUT); digitalWrite(19, LOW); //Assign an initial state to prevent floating digitalWrite(18, LOW); //Assign an initial state to prevent floating attachInterrupt(digitalPinToInterrupt(18), ScaleUp, RISING); //interrupt on Rising edge attachInterrupt(digitalPinToInterrupt(19), ScaleDown, RISING); //interrupt on Rising edge } //ISR definitions void Count1() { int A2state = digitalRead(enc1A); int B2state = digitalRead(enc1B); if (B2state == A2state) (count1>0)?(count1--):count1=0; //limit min value of count1 to 0 else (count1<127)?(count1++):count1=127; //limit max value of count1 to 127 Midi(177, 0, count1); } void Count2() { int A2state = digitalRead(enc2A); int B2state = digitalRead(enc2B); if (B2state == A2state) (count2>0)?(count2--):count2=0; //limit min value of count2 to 0 else (count2<127)?(count2++):count2=127; //limit max value of count2 to 127 Midi(177, 1, count2); } void ScaleUp() { if (millis() - last1 > 200) { //debouncing if(count < 32) count = count + 16; //Increase the scale of octave last1 = millis(); } } void ScaleDown() { if (millis() - last2 > 200) { //debouncing if(count > -60) count = count - 16; //Decrease the scale of octave last2 = millis(); } } Analog Readings #define pitchbend1 224 //on channel1 #define pitchbend2 225 //on channel2 void getPitchMod() { int32_t valueReceived; BaseType_t qStatus; while (1) { xQueueReceive(Queue1, &valueReceived, portMAX_DELAY); //wait indefinitely until trigger Midi(pitchbend2, 0, map(analogRead(modulationpin), 0, 1024, 0, 127)); Midi(pitchbend1, 0 , map(analogRead(pitchpin), 0, 1024, 0, 127)); } } void getVolume() { int32_t valueReceived; BaseType_t qStatus; while (1) { xQueueReceive(Queue2, &valueReceived, portMAX_DELAY); //wait indefinitely until trigger vol = map(analogRead(volumepin), 0, 1023, 0, 127); Midi(176, 7, vol); } } Keypads #define channel1 144 //channel1 #define channel2 145 int midC = 60; // MIDI note value for middle C on a standard keyboard void Readkey1() { BaseType_t qStatus; int32_t valueToSend = 1999; //this is just a token value while (1) { if (abs(analogRead(volumepin) - prev1) > 2) { //check if there is a change in the input reading qStatus = xQueueSend(Queue2, &valueToSend, 0); //send a dummy trigger on queue prev1 = analogRead(volumepin); } if (abs(analogRead(pitchpin) - prev2) > 3) { //check if there is a change in the input reading qStatus = xQueueSend(Queue1, &valueToSend, 0); //send a dummy trigger on queue prev2 = analogRead(pitchpin); } if (abs(analogRead(modulationpin) - prev3) > 3) { //check if there is a change in the input reading qStatus = xQueueSend(Queue1, &valueToSend, 0); //send a dummy trigger on queue prev3 = analogRead(modulationpin); } if (kpd1.getKeys()) // supports up to ten simultaneous key presses { for (int i = 0; i < LIST_MAX; i++) // scan the whole key list { if ( kpd1.key[i].stateChanged) // find keys that have changed state { if (kpd1.key[i].kstate == PRESSED) // sends MIDI on message when keys are pressed { switch (kpd1.key[i].kchar) { case 'A': Midi(channel1, midC + count + 0, volume); break; case 'B': Midi(channel1, midC + count + 1, volume); break; case 'C': Midi(channel1, midC + count + 2, volume); break; case 'D': Midi(channel1, midC + count + 3, volume); break; case 'E': Midi(channel1, midC + count + 4, volume); break; case 'F': Midi(channel1, midC + count + 5, volume); break; case 'G': Midi(channel1, midC + count + 6, volume); break; case 'H': Midi(channel1, midC + count + 7, volume); break; case 'I': Midi(channel1, midC + count + 8, volume); break; case 'J': Midi(channel1, midC + count + 9, volume); break; case 'K': Midi(channel1, midC + count + 10, volume); break; case 'L': Midi(channel1, midC + count + 11, volume); break; case 'M': Midi(channel1, midC + count + 12, volume); break; case 'N': Midi(channel1, midC + count + 13, volume); break; case 'O': Midi(channel1, midC + count + 14, volume); break; case 'P': Midi(channel1, midC + count + 15, volume); break; } } if (kpd1.key[i].kstate == RELEASED) // sends MIDI on message when keys are pressed { switch (kpd1.key[i].kchar) { case 'A': Midi(channel1 - 16, midC + count + 0, 0); break; case 'B': Midi(channel1 - 16, midC + count + 1, 0); break; case 'C': Midi(channel1 - 16, midC + count + 2, 0); break; case 'D': Midi(channel1 - 16, midC + count + 3, 0); break; case 'E': Midi(channel1 - 16, midC + count + 4, 0); break; case 'F': Midi(channel1 - 16, midC + count + 5, 0); break; case 'G': Midi(channel1 - 16, midC + count + 6, 0); break; case 'H': Midi(channel1 - 16, midC + count + 7, 0); break; case 'I': Midi(channel1 - 16, midC + count + 8, 0); break; case 'J': Midi(channel1 - 16, midC + count + 9, 0); break; case 'K': Midi(channel1 - 16, midC + count + 10, 0); break; case 'L': Midi(channel1 - 16, midC + count + 11, 0); break; case 'M': Midi(channel1 - 16, midC + count + 12, 0); break; case 'N': Midi(channel1 - 16, midC + count + 13, 0); break; case 'O': Midi(channel1 - 16, midC + count + 14, 0); break; case 'P': Midi(channel1 - 16, midC + count + 15, 0); break; } } } } } } } void Readkey2() { while (1) { if (kpd2.getKeys()) // supports up to ten simultaneous key presses { for (int i = 0; i < LIST_MAX; i++) // scan the whole key list { if ( kpd2.key[i].stateChanged) // find keys that have changed state { if (kpd2.key[i].kstate == PRESSED) // sends MIDI on message when keys are pressed { switch (kpd2.key[i].kchar) { case 'A': Midi(channel2, midC + 16 + count + 0, volume); break; case 'B': Midi(channel2, midC + 16 + count + 1, volume); break; case 'C': Midi(channel2, midC + 16 + count + 2, volume); break; case 'D': Midi(channel2, midC + 16 + count + 3, volume); break; case 'E': Midi(channel2, midC + 16 + count + 4, volume); break; case 'F': Midi(channel2, midC + 16 + count + 5, volume); break; case 'G': Midi(channel2, midC + 16 + count + 6, volume); break; case 'H': Midi(channel2, midC + 16 + count + 7, volume); break; case 'I': Midi(channel2, midC + 16 + count + 8, volume); break; case 'J': Midi(channel2, midC + 16 + count + 9, volume); break; case 'K': Midi(channel2, midC + 16 + count + 10, volume); break; case 'L': Midi(channel2, midC + 16 + count + 11, volume); break; case 'M': Midi(channel2, midC + 16 + count + 12, volume); break; case 'N': Midi(channel2, midC + 16 + count + 13, volume); break; case 'O': Midi(channel2, midC + 16 + count + 14, volume); break; case 'P': Midi(channel2, midC + 16 + count + 15, volume); break; } } if (kpd2.key[i].kstate == RELEASED) // sends MIDI on message when keys are pressed { switch (kpd2.key[i].kchar) { case 'A': Midi(channel2 - 16, midC + 16 + count + 0, 0); break; case 'B': Midi(channel2 - 16, midC + 16 + count + 1, 0); break; case 'C': Midi(channel2 - 16, midC + 16 + count + 2, 0); break; case 'D': Midi(channel2 - 16, midC + 16 + count + 3, 0); break; case 'E': Midi(channel2 - 16, midC + 16 + count + 4, 0); break; case 'F': Midi(channel2 - 16, midC + 16 + count + 5, 0); break; case 'G': Midi(channel2 - 16, midC + 16 + count + 6, 0); break; case 'H': Midi(channel2 - 16, midC + 16 + count + 7, 0); break; case 'I': Midi(channel2 - 16, midC + 16 + count + 8, 0); break; case 'J': Midi(channel2 - 16, midC + 16 + count + 9, 0); break; case 'K': Midi(channel2 - 16, midC + 16 + count + 10, 0); break; case 'L': Midi(channel2 - 16, midC + 16 + count + 11, 0); break; case 'M': Midi(channel2 - 16, midC + 16 + count + 12, 0); break; case 'N': Midi(channel2 - 16, midC + 16 + count + 13, 0); break; case 'O': Midi(channel2 - 16, midC + 16 + count + 14, 0); break; case 'P': Midi(channel2 - 16, midC + 16 + count + 15, 0); break; } } } } } } }","title":"Code"},{"location":"Firmware/#code","text":"Go through the following code.","title":"Code"},{"location":"Firmware/#pin-declarations-and-definitions","text":"#include <Arduino_FreeRTOS.h> #include \"queue.h\" #include <Keypad.h> //analog input pins #define pitchpin A0 #define modulationpin A2 #define volumepin A1 //Keypad related declarations const byte ROWS = 4; //four rows const byte COLS = 4; //four columns char keys1[ROWS][COLS] = { {'A', 'B', 'C', 'D'}, {'E', 'F', 'G', 'H'}, {'I', 'J', 'K', 'L'}, {'M', 'N', 'O', 'P'} }; byte rowPins[ROWS] = {22, 24, 26, 28}; //connect to the row pinouts of the kpd1 byte colPins[COLS] = {29, 27, 25, 23}; //connect to the column pinouts of the kpd1 Keypad kpd1 = Keypad( makeKeymap(keys1), rowPins, colPins, ROWS, COLS ); char keys2[ROWS][COLS] = { {'A', 'B', 'C', 'D'}, {'E', 'F', 'G', 'H'}, {'I', 'J', 'K', 'L'}, {'M', 'N', 'O', 'P'} }; byte colpins[COLS] = {47, 42, 36, 34}; //connect to the row pinouts of the kpd2 byte rowpins[ROWS] = {48, 43, 37, 35}; //connect to the column pinouts of the kpd2 Keypad kpd2 = Keypad( makeKeymap(keys2), rowpins, colpins, ROWS, COLS ); int volume = 100; //Interrupt related declarations #define enc1A 20 #define enc2A 21 #define enc1B 31 #define enc2B 33 #define pb1 18 //pushbutton #define pb2 19 //pushbutton volatile int count1 = 64; volatile int count2 = 64; volatile int count = 0; volatile long last1 = 0; volatile long last2 = 0; //Queue Creation QueueHandle_t Queue1,Queue2; int prev1 = 0, prev2 = 515, prev3 = 517; int vol = 100; void setup() { Serial.begin(115200); pinMode(pitchpin, INPUT); pinMode(modulationpin, INPUT); pinMode(volumepin, INPUT); interrupt_set(); xTaskCreate(Readkey1, \"one\", 128, NULL, 0, NULL); //task for pushbutton keypad xTaskCreate(Readkey2, \"two\", 128, NULL, 0, NULL); //task for membrane keypad xTaskCreate(getPitchMod, \"pitch_mod\", 128, NULL, 2, NULL); //task for pitch bends xTaskCreate(getVolume, \"vol\", 100, NULL, 2, NULL); //task for channel volume Queue1 = xQueueCreate(5, sizeof(int32_t)); Queue2 = xQueueCreate(5, sizeof(int32_t)); } void loop() { } void Midi(int status, int dat1, int dat2) { //MIDI message structure consists of three bytes Serial.write(status); Serial.write(dat1); Serial.write(dat2); }","title":"Pin declarations and definitions"},{"location":"Firmware/#interrupts","text":"void interrupt_set() { pinMode( enc1A, INPUT); digitalWrite(enc1A, HIGH); //Assign an initial state to prevent floating pinMode(enc1B, INPUT); digitalWrite(enc1B, HIGH); //Assign an initial state to prevent floating attachInterrupt(digitalPinToInterrupt(enc1A), Count1, RISING); //interrupt on Rising edge pinMode( enc2A, INPUT); digitalWrite(enc2A, HIGH); //Assign an initial state to prevent floating pinMode(enc2B, INPUT); digitalWrite(enc2B, HIGH); //Assign an initial state to prevent floating attachInterrupt(digitalPinToInterrupt(enc2A), Count2, RISING); //interrupt on Rising edge pinMode( pb1, INPUT); digitalWrite(pb1, HIGH); //Assign an initial state to prevent floating attachInterrupt(digitalPinToInterrupt(pb1), PB1, RISING); //interrupt on Rising edge pinMode( pb2, INPUT); digitalWrite(pb2, HIGH); //Assign an initial state to prevent floating attachInterrupt(digitalPinToInterrupt(pb2), PB2, RISING); //interrupt on Rising edge pinMode(18, INPUT); pinMode(19, INPUT); digitalWrite(19, LOW); //Assign an initial state to prevent floating digitalWrite(18, LOW); //Assign an initial state to prevent floating attachInterrupt(digitalPinToInterrupt(18), ScaleUp, RISING); //interrupt on Rising edge attachInterrupt(digitalPinToInterrupt(19), ScaleDown, RISING); //interrupt on Rising edge } //ISR definitions void Count1() { int A2state = digitalRead(enc1A); int B2state = digitalRead(enc1B); if (B2state == A2state) (count1>0)?(count1--):count1=0; //limit min value of count1 to 0 else (count1<127)?(count1++):count1=127; //limit max value of count1 to 127 Midi(177, 0, count1); } void Count2() { int A2state = digitalRead(enc2A); int B2state = digitalRead(enc2B); if (B2state == A2state) (count2>0)?(count2--):count2=0; //limit min value of count2 to 0 else (count2<127)?(count2++):count2=127; //limit max value of count2 to 127 Midi(177, 1, count2); } void ScaleUp() { if (millis() - last1 > 200) { //debouncing if(count < 32) count = count + 16; //Increase the scale of octave last1 = millis(); } } void ScaleDown() { if (millis() - last2 > 200) { //debouncing if(count > -60) count = count - 16; //Decrease the scale of octave last2 = millis(); } }","title":"Interrupts"},{"location":"Firmware/#analog-readings","text":"#define pitchbend1 224 //on channel1 #define pitchbend2 225 //on channel2 void getPitchMod() { int32_t valueReceived; BaseType_t qStatus; while (1) { xQueueReceive(Queue1, &valueReceived, portMAX_DELAY); //wait indefinitely until trigger Midi(pitchbend2, 0, map(analogRead(modulationpin), 0, 1024, 0, 127)); Midi(pitchbend1, 0 , map(analogRead(pitchpin), 0, 1024, 0, 127)); } } void getVolume() { int32_t valueReceived; BaseType_t qStatus; while (1) { xQueueReceive(Queue2, &valueReceived, portMAX_DELAY); //wait indefinitely until trigger vol = map(analogRead(volumepin), 0, 1023, 0, 127); Midi(176, 7, vol); } }","title":"Analog Readings"},{"location":"Firmware/#keypads","text":"#define channel1 144 //channel1 #define channel2 145 int midC = 60; // MIDI note value for middle C on a standard keyboard void Readkey1() { BaseType_t qStatus; int32_t valueToSend = 1999; //this is just a token value while (1) { if (abs(analogRead(volumepin) - prev1) > 2) { //check if there is a change in the input reading qStatus = xQueueSend(Queue2, &valueToSend, 0); //send a dummy trigger on queue prev1 = analogRead(volumepin); } if (abs(analogRead(pitchpin) - prev2) > 3) { //check if there is a change in the input reading qStatus = xQueueSend(Queue1, &valueToSend, 0); //send a dummy trigger on queue prev2 = analogRead(pitchpin); } if (abs(analogRead(modulationpin) - prev3) > 3) { //check if there is a change in the input reading qStatus = xQueueSend(Queue1, &valueToSend, 0); //send a dummy trigger on queue prev3 = analogRead(modulationpin); } if (kpd1.getKeys()) // supports up to ten simultaneous key presses { for (int i = 0; i < LIST_MAX; i++) // scan the whole key list { if ( kpd1.key[i].stateChanged) // find keys that have changed state { if (kpd1.key[i].kstate == PRESSED) // sends MIDI on message when keys are pressed { switch (kpd1.key[i].kchar) { case 'A': Midi(channel1, midC + count + 0, volume); break; case 'B': Midi(channel1, midC + count + 1, volume); break; case 'C': Midi(channel1, midC + count + 2, volume); break; case 'D': Midi(channel1, midC + count + 3, volume); break; case 'E': Midi(channel1, midC + count + 4, volume); break; case 'F': Midi(channel1, midC + count + 5, volume); break; case 'G': Midi(channel1, midC + count + 6, volume); break; case 'H': Midi(channel1, midC + count + 7, volume); break; case 'I': Midi(channel1, midC + count + 8, volume); break; case 'J': Midi(channel1, midC + count + 9, volume); break; case 'K': Midi(channel1, midC + count + 10, volume); break; case 'L': Midi(channel1, midC + count + 11, volume); break; case 'M': Midi(channel1, midC + count + 12, volume); break; case 'N': Midi(channel1, midC + count + 13, volume); break; case 'O': Midi(channel1, midC + count + 14, volume); break; case 'P': Midi(channel1, midC + count + 15, volume); break; } } if (kpd1.key[i].kstate == RELEASED) // sends MIDI on message when keys are pressed { switch (kpd1.key[i].kchar) { case 'A': Midi(channel1 - 16, midC + count + 0, 0); break; case 'B': Midi(channel1 - 16, midC + count + 1, 0); break; case 'C': Midi(channel1 - 16, midC + count + 2, 0); break; case 'D': Midi(channel1 - 16, midC + count + 3, 0); break; case 'E': Midi(channel1 - 16, midC + count + 4, 0); break; case 'F': Midi(channel1 - 16, midC + count + 5, 0); break; case 'G': Midi(channel1 - 16, midC + count + 6, 0); break; case 'H': Midi(channel1 - 16, midC + count + 7, 0); break; case 'I': Midi(channel1 - 16, midC + count + 8, 0); break; case 'J': Midi(channel1 - 16, midC + count + 9, 0); break; case 'K': Midi(channel1 - 16, midC + count + 10, 0); break; case 'L': Midi(channel1 - 16, midC + count + 11, 0); break; case 'M': Midi(channel1 - 16, midC + count + 12, 0); break; case 'N': Midi(channel1 - 16, midC + count + 13, 0); break; case 'O': Midi(channel1 - 16, midC + count + 14, 0); break; case 'P': Midi(channel1 - 16, midC + count + 15, 0); break; } } } } } } } void Readkey2() { while (1) { if (kpd2.getKeys()) // supports up to ten simultaneous key presses { for (int i = 0; i < LIST_MAX; i++) // scan the whole key list { if ( kpd2.key[i].stateChanged) // find keys that have changed state { if (kpd2.key[i].kstate == PRESSED) // sends MIDI on message when keys are pressed { switch (kpd2.key[i].kchar) { case 'A': Midi(channel2, midC + 16 + count + 0, volume); break; case 'B': Midi(channel2, midC + 16 + count + 1, volume); break; case 'C': Midi(channel2, midC + 16 + count + 2, volume); break; case 'D': Midi(channel2, midC + 16 + count + 3, volume); break; case 'E': Midi(channel2, midC + 16 + count + 4, volume); break; case 'F': Midi(channel2, midC + 16 + count + 5, volume); break; case 'G': Midi(channel2, midC + 16 + count + 6, volume); break; case 'H': Midi(channel2, midC + 16 + count + 7, volume); break; case 'I': Midi(channel2, midC + 16 + count + 8, volume); break; case 'J': Midi(channel2, midC + 16 + count + 9, volume); break; case 'K': Midi(channel2, midC + 16 + count + 10, volume); break; case 'L': Midi(channel2, midC + 16 + count + 11, volume); break; case 'M': Midi(channel2, midC + 16 + count + 12, volume); break; case 'N': Midi(channel2, midC + 16 + count + 13, volume); break; case 'O': Midi(channel2, midC + 16 + count + 14, volume); break; case 'P': Midi(channel2, midC + 16 + count + 15, volume); break; } } if (kpd2.key[i].kstate == RELEASED) // sends MIDI on message when keys are pressed { switch (kpd2.key[i].kchar) { case 'A': Midi(channel2 - 16, midC + 16 + count + 0, 0); break; case 'B': Midi(channel2 - 16, midC + 16 + count + 1, 0); break; case 'C': Midi(channel2 - 16, midC + 16 + count + 2, 0); break; case 'D': Midi(channel2 - 16, midC + 16 + count + 3, 0); break; case 'E': Midi(channel2 - 16, midC + 16 + count + 4, 0); break; case 'F': Midi(channel2 - 16, midC + 16 + count + 5, 0); break; case 'G': Midi(channel2 - 16, midC + 16 + count + 6, 0); break; case 'H': Midi(channel2 - 16, midC + 16 + count + 7, 0); break; case 'I': Midi(channel2 - 16, midC + 16 + count + 8, 0); break; case 'J': Midi(channel2 - 16, midC + 16 + count + 9, 0); break; case 'K': Midi(channel2 - 16, midC + 16 + count + 10, 0); break; case 'L': Midi(channel2 - 16, midC + 16 + count + 11, 0); break; case 'M': Midi(channel2 - 16, midC + 16 + count + 12, 0); break; case 'N': Midi(channel2 - 16, midC + 16 + count + 13, 0); break; case 'O': Midi(channel2 - 16, midC + 16 + count + 14, 0); break; case 'P': Midi(channel2 - 16, midC + 16 + count + 15, 0); break; } } } } } } }","title":"Keypads"},{"location":"Simulation/","text":"Simulation A simple circuit using eYFI Mega was simulated on e-Yantra Circuit Simulator, which is a flavor of SimulIDE circuit simulator (download here ). The firmware was loaded on the virtual eYFI Mega board and certain notes were generated, besides exhibiting characteristics such as pitch bend, scale change and volume change. Virtual COM ports were created using Virtual Serial Port Driver which were used for passing serial data from the eYFI Mega board to the DAW via simulator and Hairless MIDI<->Serial Bridge The firmware for the above configuration can be found here . Click here to get the simulation file for the above configuration.","title":"Simulation"},{"location":"Simulation/#simulation","text":"A simple circuit using eYFI Mega was simulated on e-Yantra Circuit Simulator, which is a flavor of SimulIDE circuit simulator (download here ). The firmware was loaded on the virtual eYFI Mega board and certain notes were generated, besides exhibiting characteristics such as pitch bend, scale change and volume change. Virtual COM ports were created using Virtual Serial Port Driver which were used for passing serial data from the eYFI Mega board to the DAW via simulator and Hairless MIDI<->Serial Bridge The firmware for the above configuration can be found here . Click here to get the simulation file for the above configuration.","title":"Simulation"},{"location":"Software/","text":"Software Software used Ableton 9 DAW (Download here ) Hairless MIDI<->Serial Bridge (Download here ) loopmidi (Download here ) e-Yantra IDE for eYFi Mega (a flavor of Arduino IDE) Applications of different software Ableton 9 is a Digital Audio Workstation. It takes in MIDI messages as input, and then behaves accordingly to the specified messages. It is used for producing the sounds/music that we can hear. The MIDI controller does not produce music, it is this software that produces the notes/sounds. Loopmidi is used to create a virtual MIDI port. Since, we do not have a MIDI port in any conventional laptop, it is this virtual port through which the midi messages are passed to Ableton 9 . Hairless MIDI<->Serial Bridge , as the name suggests acts as a bridge to convert the MIDI messages sent via serial port of the microcontroller to appropriate MIDI data, which is sent through the virtual port created by loopmidi and eventually interpreted by the DAW. e-Yantra IDE is a spinoff of traditional Arduino IDE, with custom bootloader for the eYFi Mega development board. It follows the same programming convention as Arduino IDE, and is used to upload programs to the eYFi Mega board. Software Integration Firstly, launch loopmidi and create a port. The default name of the port is loopMIDI Port . Next launch Hairless MIDI<->Serial Bridge . Select the serial port with which the board is connected. Also, select the MIDI Out port, The default port being loopMIDI Port . The MIDI messages can be debugged by ticking the Debug MIDI messages checkbox. Now, launch Ableton 9. Go to preferences to set the input MIDI port. Now one would see incoming MIDI messages in the top right corner. A blinking light exhibits that Ableton 9 is receiving MIDI messages. We can also map the inputs of the e-Yantra Midi Vaadan, with different parameters in Ableton 9. This can be done by clicking on the MIDI tab on top right corner. This will activate the MIDI mapping mode. The ones highlighted in blue can be mapped. Just select any one of the highlighted parameter/controller, that needs to be manipulated by input, and then give certain input (for e.g, rotate a potentiometer, press a button), and it will get bound with the one in software.","title":"Software"},{"location":"Software/#software","text":"","title":"Software"},{"location":"Software/#software-used","text":"Ableton 9 DAW (Download here ) Hairless MIDI<->Serial Bridge (Download here ) loopmidi (Download here ) e-Yantra IDE for eYFi Mega (a flavor of Arduino IDE)","title":"Software used"},{"location":"Software/#applications-of-different-software","text":"Ableton 9 is a Digital Audio Workstation. It takes in MIDI messages as input, and then behaves accordingly to the specified messages. It is used for producing the sounds/music that we can hear. The MIDI controller does not produce music, it is this software that produces the notes/sounds. Loopmidi is used to create a virtual MIDI port. Since, we do not have a MIDI port in any conventional laptop, it is this virtual port through which the midi messages are passed to Ableton 9 . Hairless MIDI<->Serial Bridge , as the name suggests acts as a bridge to convert the MIDI messages sent via serial port of the microcontroller to appropriate MIDI data, which is sent through the virtual port created by loopmidi and eventually interpreted by the DAW. e-Yantra IDE is a spinoff of traditional Arduino IDE, with custom bootloader for the eYFi Mega development board. It follows the same programming convention as Arduino IDE, and is used to upload programs to the eYFi Mega board.","title":"Applications of different software"},{"location":"Software/#software-integration","text":"Firstly, launch loopmidi and create a port. The default name of the port is loopMIDI Port . Next launch Hairless MIDI<->Serial Bridge . Select the serial port with which the board is connected. Also, select the MIDI Out port, The default port being loopMIDI Port . The MIDI messages can be debugged by ticking the Debug MIDI messages checkbox. Now, launch Ableton 9. Go to preferences to set the input MIDI port. Now one would see incoming MIDI messages in the top right corner. A blinking light exhibits that Ableton 9 is receiving MIDI messages. We can also map the inputs of the e-Yantra Midi Vaadan, with different parameters in Ableton 9. This can be done by clicking on the MIDI tab on top right corner. This will activate the MIDI mapping mode. The ones highlighted in blue can be mapped. Just select any one of the highlighted parameter/controller, that needs to be manipulated by input, and then give certain input (for e.g, rotate a potentiometer, press a button), and it will get bound with the one in software.","title":"Software Integration"},{"location":"hardware/","text":"Hardware Components required: eYFi Mega Development Board 1x Sliding Potentiometer 1x Dual Axis Joystick 1x Membrane Keypad 1x Push Button Keypad 2x Rotary Encoder 3x push button Jumper wires (male-male, male-female, female-female) Circuit Schematic: One may refer to the Arduino Mega pin mapping with ATMega 2560 so as to code in the e-Yantra IDE for eYFi Mega (which is a flavor of Arduino IDE).","title":"Hardware"},{"location":"hardware/#hardware","text":"","title":"Hardware"},{"location":"hardware/#components-required","text":"eYFi Mega Development Board 1x Sliding Potentiometer 1x Dual Axis Joystick 1x Membrane Keypad 1x Push Button Keypad 2x Rotary Encoder 3x push button Jumper wires (male-male, male-female, female-female)","title":"Components required:"},{"location":"hardware/#circuit-schematic","text":"One may refer to the Arduino Mega pin mapping with ATMega 2560 so as to code in the e-Yantra IDE for eYFi Mega (which is a flavor of Arduino IDE).","title":"Circuit Schematic:"},{"location":"references/","text":"References Rotary Encoder Interfacing Check here Sliding Potentiometer Interfacing Check here Dual axis Joystick Interfacing Check here Keypad Interfacing Check here","title":"References"},{"location":"references/#references","text":"","title":"References"},{"location":"references/#rotary-encoder-interfacing","text":"Check here","title":"Rotary Encoder Interfacing"},{"location":"references/#sliding-potentiometer-interfacing","text":"Check here","title":"Sliding Potentiometer Interfacing"},{"location":"references/#dual-axis-joystick-interfacing","text":"Check here","title":"Dual axis Joystick Interfacing"},{"location":"references/#keypad-interfacing","text":"Check here","title":"Keypad Interfacing"}]}